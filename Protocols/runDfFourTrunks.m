function sol = runDfFourTrunks(sol_in, par, maxDepth, parentStepID, accumulatedTime, debug, suggestedTimes)
%RUNDFFOURTRUNKS - Splits the requested simulation time in smaller pieces until when the simulation succeeds
% Equivalent to running directly DF, but does not give up easily when the
% PDEPE does not manage to converge.
% Designed for working with logarithmic time mesh (tmesh_type = 2 or "log10")
% The debug function will not work if sol_in and par have a different number of mobile
% species (e.g. if sol_in has no mobile ions and par activates the ionic mobility)
% 
% Syntax:  sol = runDfFourTrunks(sol_in, par, maxDepth, parentStepID, accumulatedTime, debug, suggestedTimes)
%
% Inputs:
%   SOL_IN - a solution struct as created by DF.
%   PAR - the parameters set of the needed simulation to perform, as generated by PC.
%   MAXDEPTH - optional integer, the maximum number of times a solution can be
%     broken before giving up. For avoiding this limit, an Inf value can be
%     provided.
%   PARENTSTEPID - optional characters array, for internal use, set an
%     empty value '' if needed.
%   ACCUMULATEDTIME - optional float, set 0 if needed.
%   DEBUG - optional logical, set true for having all the solutions saved
%     to the workspace.
%   SUGGESTEDTIMES - optional float, for internal use.
%
% Outputs:
%   SOL - the complete solution obtained, the number of time points could
%     be much larger than the requested one in par.tpoints
%
% Example:
%   sol = runDfFourTrunks(sol_in, par)
%     executes the DF until when it converges
%
% Other m-files required: df, dfana, mergeSolutions
% Subfunctions: check_and_recurse
% MAT-files required: none
%
% See also df.
%
%% LICENSE
% Copyright (C) 2021  Philip Calado, Ilario Gelmetti, and Piers R. F. Barnes
% Imperial College London
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU Affero General Public License as published
% by the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
%------------- BEGIN CODE --------------
    assert(strcmp(par.tmesh_type, 'log10') || par.tmesh_type == 2, [mfilename ' - This script has been designed for working with logarithmic time mesh. Please indicate a suitable par.tmesh_type value.']);
    if nargin < 6
        debug = false;
        if nargin < 5
            accumulatedTime = 0;
            if nargin < 4
                parentStepID = '';
                if nargin < 3
                    maxDepth = Inf;
                end
            end
        end
    end
        
    suggestedTimes_arr = [Inf, Inf, Inf];
    if nargin == 7
        suggestedTimes_arr(1:length(suggestedTimes)) = suggestedTimes;
    end
    
    %%
    ID = '1';
    par1 = par;
    if par.t0
        refMinTime = min(par.t0*10, par.tmax/10);
    else
        refMinTime = par.tmax/10;
    end
    if isfinite(suggestedTimes_arr(1))
        par1.tmax = suggestedTimes_arr(1);
    else
        par1.tmax = (refMinTime^1.5*par.tmax^0.5)^0.5;
    end
    par1.t0 = min(refMinTime, par1.tmax/20);
    
    disp([mfilename ' - ' char(datetime('now')) ' - Split solution, part ' parentStepID ID '. Start time point: ' num2str(accumulatedTime) ' s; t0: ' num2str(par1.t0) ' s; tmax: ' num2str(par1.tmax) ' s'])
    par1.tpoints = max(floor(par.tpoints / 4), 20);
    sol1 = df(sol_in, par1);
    [sol1, sol_sofar] = check_and_recurse(sol1, sol_in, maxDepth, parentStepID, ID, accumulatedTime, debug);
    accumulatedTime = accumulatedTime + par1.tmax;

    %%
    ID = '2';
    par2 = par;
    par2.tmax = min([suggestedTimes_arr(2), (par.tmax-par1.tmax)/10]);%, (refMinTime*par.tmax)^0.5 - par1.tmax);
    par2.t0 = min(par1.tmax, par2.tmax/20);
    disp([mfilename ' - ' char(datetime('now')) ' - Split solution, part ' parentStepID ID '. Start time point: ' num2str(accumulatedTime) ' s; t0: ' num2str(par2.t0) ' s; tmax: ' num2str(par2.tmax) ' s'])
    par2.tpoints = max(floor(par.tpoints / 4), 20);
    sol2 = df(sol1, par2);
    [sol2, sol_sofar] = check_and_recurse(sol2, sol_sofar, maxDepth, parentStepID, ID, accumulatedTime, debug);
    accumulatedTime = accumulatedTime + par2.tmax;

    %%
    ID = '3';
    par3 = par;
    par3.tmax = min([suggestedTimes_arr(3), (par.tmax-par1.tmax-par2.tmax)/4]);%(refMinTime^0.5*par.tmax^1.5)^0.5 - par1.tmax - par2.tmax]);
    par3.t0 = min(par2.tmax, par3.tmax/20);
    disp([mfilename ' - ' char(datetime('now')) ' - Split solution, part ' parentStepID ID '. Start time point: ' num2str(accumulatedTime) ' s; t0: ' num2str(par3.t0) ' s; tmax: ' num2str(par3.tmax) ' s'])
    par3.tpoints = max(floor(par.tpoints / 4), 20);
    sol3 = df(sol2, par3);
    [sol3, sol_sofar] = check_and_recurse(sol3, sol_sofar, maxDepth, parentStepID, ID, accumulatedTime, debug);
    accumulatedTime = accumulatedTime + par3.tmax;
    
    %%    
    ID = '4';
    par4 = par;
    par4.tmax = par.tmax - par1.tmax - par2.tmax - par3.tmax;
    % check if the parent recursion loop broke at short times, in that case
    % force recursion
    if par4.tmax < suggestedTimes_arr(3) * 5
        par4.t0 = min(par3.tmax, par4.tmax/20);
        disp([mfilename ' - ' char(datetime('now')) ' - Split solution, part ' parentStepID ID '. Start time point: ' num2str(accumulatedTime) ' s; t0: ' num2str(par4.t0) ' s; tmax: ' num2str(par4.tmax) ' s'])
        par4.tpoints = max(par.tpoints - par1.tpoints - par2.tpoints - par3.tpoints, 20);
        sol4 = df(sol3, par4);
    else
        % force recursion
        disp([mfilename ' - ' char(datetime('now')) ' - Further breaking the solution in four trunks due to too large fourth step.'])
        newExtraOutput = [parentStepID ID '.'];
        suggested_times_arr_new = [suggestedTimes_arr(3), suggestedTimes_arr(3), 2*suggestedTimes_arr(3)];
        sol4 = runDfFourTrunks(sol_sofar, par4, maxDepth-1, newExtraOutput, accumulatedTime, debug, suggested_times_arr_new);
    end
    sol4 = check_and_recurse(sol4, sol_sofar, maxDepth, parentStepID, ID, accumulatedTime, debug);
    sol = mergeSolutions(sol1, sol2, sol3, sol4);
end  

function [sol, sol_sofar] = check_and_recurse(sol_in, sol_sofar, maxDepth, parentStepID, ID, accumulatedTime, debug)
    if size(sol_in.u,1) ~= sol_in.par.tpoints
        disp([mfilename ' - ' char(datetime('now')) ' - Further breaking the solution in four trunks due to broken solution.'])
        recurse = true;
        % the solution can have zero time points, and the first time point
        % can be t=0
        suggestedTime = max(sol_in.par.t0, sol_in.t(max(1, size(sol_in.u,1))));
        suggestedTimes_arr = [suggestedTime,suggestedTime,suggestedTime];
    else
        Jtot_endx = dfana.calcJ(sol_in).tot(:,end);
        outliers = isoutlier(Jtot_endx,'ThresholdFactor',30);
        % set to false all the points in where the change is ridicolously
        % small
        outliers((Jtot_endx - mean(Jtot_endx))./Jtot_endx < 0.001) = false;
        % exclude the first points
        outliers_tail = outliers(floor(length(outliers)*0.4):end);
        if any(outliers_tail) % can be tuned with 'ThresholdFactor', 'movmedian' or 'movmean'
            disp([mfilename ' - ' char(datetime('now')) ' - Further breaking the solution in four trunks due to suspicious current.'])
            recurse = true;
            suggestedTimes_arr = Inf;
        else
            recurse = false;
        end
    end
    if recurse
        newExtraOutput = [parentStepID ID '.'];
        if debug
            assignin('base', matlab.lang.makeValidName(['sol_broken_' newExtraOutput]), sol_in);
        end
        if maxDepth
            sol = runDfFourTrunks(sol_sofar, sol_in.par, maxDepth-1, newExtraOutput, accumulatedTime, debug, suggestedTimes_arr);
        else
            error([mfilename ' - Reached the maximum recursion depth indicated via maxDepth, giving up.'])
            %sol = df(sol_sofar, par_steadyState);
        end
    else
        sol = sol_in;
    end
    if debug
        sol_sofar = mergeSolutions(sol_sofar, sol);
        assignin('base', matlab.lang.makeValidName(['sol_trunks_' parentStepID ID]), sol_sofar);
    else
        sol_sofar = sol;
    end
end

%------------- END OF CODE --------------